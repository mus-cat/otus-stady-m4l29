# NFTABLES
## Задание выполнялось с использованием VirtualBox 6.1.40, использовался vagrant с box-образом generic/debian10

## Задание:
- Реализовать **knocking port**. `CentralRouter` может попасть по **ssh** на `inetrRouter1` через knock скрипт
    пример в материалах.
- Добавить `inetRouter2`, который виден(маршрутизируется (host-only тип сети для виртуалки)) с хоста или форвардится порт через локалхост. Запустить **nginx** на `centralServer` и пробросить 80-ый порт на `inetRouter2` `8080`.  Маршрут в инет оставить через `inetRouter1`.
- (задание со \*) Реализовать предыдущее задание без маскарадинга.

## Решение

Для демонстрации решения поставленных задач реализована следующая схема сети  
!["Схема сети"](https://github.com/mus-cat/otus-study-m1l7/blob/main/01.BuildDirContent.png)

### Описание сети
- `inetRouter1` - маршрутизатор через который по-умолчанию осуществляется доступ в интернет, для этого на нем пакеты проходят через **NAT**. На нем же реализован **portknocking**.
- `inetRouter2` - маршрутизатор ожидающий подключения на порты 8080 и 8081, которые в дальнейшем перенаправляются соответственно на порты 80 и 81 `centralServer`.
- `centralRouter` - осуществляет маршрутизацию внетри сети, и в частности выступающий шлюзом по-умолчанию для `centralServer`.
- `centralServer` - сервер на которм работает **nginx** и слушает порты 80 и 81 (на них выдается одна и таже страница).

### Portknoking
1. **Portknocking**  
**Portknocking** реализован только при подключении по **ssh** на внутренний интерфейс маршрутизатора `inetRouter1` (ip - 192.168.1.2). При подключении по **ssh** на внешней интерфейс (ip - 10.0.2.15) portknocking не используется. Для подключения по **ssh**  к внутреннему интерфейсу необходимо последовтально постучаться на порты `111` -> `222` -> `333` -> `22`. Это можно реализовать выполнив на любо из остальных ВМ к примеру команду: 
```
for i in $(seq 1 3); do nc -w 1 192.168.1.2 "$i$i$i"; done; ssh vagrant@192.168.1.2
```
Пароль для пользователя `vagrant` - **vagrant**

2. Проброс портов с `inetRouter2` на `centralServer`  
Предварительный анализ проблем:  
Во-первых, чтобы пакеты приходящие на `inetRouter2` смогли достигнуть `centralServer` в них должен быть из менён адрес и порт назначения.  
Во-вторых, если маршрут по-умолчанию в интернет остаётся через `inetRouter1`, то пакеты посланные `centralServer` в ответ на запросы внешнего клиента (из условного интернета), без дополнительных ухищрений, будут уходить через этот маршрутизатор. А следовательно приходить к клиенту не с того адресса с которого он ожидал и будут отбрасываться.  
Для решение первой проблемы, пакеты пришедшие на `inetRouter2` из интернета (на порты `8080` и `8081`) будут проходит через **DNAT**. У входящих паетов будет заменятся адрес и порт назначения.  
Для решения воторой проблемы есть два варианта:
- Использовать **NAT** (**Masquerade**) для внешних адресов, и заменять внешний адрес на адрес внутреннего интерфейса `inetRouter2` (ip - 192.168.1.6). Этот подход реализован для пакетов приходящих на порт `8080` внешнего интерфейса `inetRouter2`.
- Использовать **PBR** (Policy-Base Routing) на `centralRouter`. Идея состоят в том, что все пакеты приходящий от `centralServer` с порта 81 и имеющие внешний адрес маркируются. Для маркированных пакетов шлюзом по-умолчанию назначен `inetRouter2`, с этой целью создается выделенная таблица маршрутизаци (команда **ip route ...**) и правило на основании которого к пакетам применяются правила из таблицы (команда **ip rules ...** ). Этот подход реализован для пакетов приходящих на порт `8081` внешнего интерфейса `inetRouter2`.

### Файлы:
- **Vagrant** - файл для создания ВМ и запуска ansible
- **server.yml** - ansible playbook для настройки `centralServer`
- **centralROuter.yml, inetRouter1.yml, inetRouter2.yml** - ansible playbook для настройки маршрутизаторов
- **portknocking.nft** - правила для **nftables** реализующие portknocking на `inetRouter1`
- **portforward.nft** - правила для **nftables** реализующие перенеправление и **NAT** на `inetRouter2`
- **mark.nft** - правила для **nftables** реализующие маркировку пакетов на `centralServer`
